import {
  __commonJS
} from "./chunk-QWN5BXRD.js";

// node_modules/.pnpm/furigana-markdown-it@1.0.3/node_modules/furigana-markdown-it/lib/ruby.js
var require_ruby = __commonJS({
  "node_modules/.pnpm/furigana-markdown-it@1.0.3/node_modules/furigana-markdown-it/lib/ruby.js"(exports, module) {
    "use strict";
    module.exports.parse = parse;
    module.exports.addTag = addTag;
    function parse(state) {
      if (state.src.charAt(state.pos) !== "[") {
        return null;
      }
      const bodyStartBracket = state.pos;
      const bodyEndBracket = state.src.indexOf("]", bodyStartBracket);
      if (bodyEndBracket === -1 || bodyEndBracket >= state.posMax || state.src.charAt(bodyEndBracket + 1) !== "{") {
        return null;
      }
      const toptextStartBracket = bodyEndBracket + 1;
      const toptextEndBracket = state.src.indexOf("}", toptextStartBracket);
      if (toptextEndBracket === -1 || toptextEndBracket >= state.posMax) {
        return null;
      }
      const body = state.src.slice(bodyStartBracket + 1, bodyEndBracket);
      const toptext = state.src.slice(toptextStartBracket + 1, toptextEndBracket);
      if (body.trim() === "" || toptext.trim() === "") {
        return null;
      }
      return {
        body,
        toptext,
        nextPos: toptextEndBracket + 1
      };
    }
    function addTag(state, content, fallbackParens = "") {
      function pushText(text) {
        const token = state.push("text", "", 0);
        token.content = text;
      }
      state.push("ruby_open", "ruby", 1);
      for (let i = 0; i < content.length; i += 2) {
        const body = content[i];
        const toptext = content[i + 1];
        pushText(body);
        if (toptext === "") {
          state.push("rt_open", "rt", 1);
          state.push("rt_close", "rt", -1);
          continue;
        }
        if (fallbackParens !== "") {
          state.push("rp_open", "rp", 1);
          pushText(fallbackParens.charAt(0));
          state.push("rp_close", "rp", -1);
        }
        state.push("rt_open", "rt", 1);
        pushText(toptext);
        state.push("rt_close", "rt", -1);
        if (fallbackParens !== "") {
          state.push("rp_open", "rp", 1);
          pushText(fallbackParens.charAt(1));
          state.push("rp_close", "rp", -1);
        }
      }
      state.push("ruby_close", "ruby", -1);
    }
  }
});

// node_modules/.pnpm/furigana-markdown-it@1.0.3/node_modules/furigana-markdown-it/lib/furigana.js
var require_furigana = __commonJS({
  "node_modules/.pnpm/furigana-markdown-it@1.0.3/node_modules/furigana-markdown-it/lib/furigana.js"(exports, module) {
    "use strict";
    module.exports = furigana;
    var rubyHelper = require_ruby();
    var kanaRegex = /[\u3040-\u3096\u30a1-\u30fa\uff66-\uff9fー]/;
    var kanjiRegex = /[\u3400-\u9faf]/;
    function bodyToRegex(body) {
      let regexStr = "^";
      let lastType = "other";
      const combinatorOrSeparatorGroup = "([+.]?)";
      const combinatorOrSeparator = "[+.]?";
      const combinatorOnly = "\\.?";
      const furiganaGroup = "([^+.]+)";
      for (let i = 0; i < body.length; i++) {
        const c = body.charAt(i);
        if (kanjiRegex.test(c)) {
          if (lastType === "kanji") {
            regexStr += combinatorOrSeparatorGroup;
          } else if (lastType === "kana") {
            regexStr += combinatorOrSeparator;
          }
          regexStr += furiganaGroup;
          lastType = "kanji";
        } else if (kanaRegex.test(c)) {
          if (lastType == "kanji") {
            regexStr += combinatorOrSeparator;
          }
          regexStr += c;
          lastType = "kana";
        } else {
          if (lastType !== "other") {
            regexStr += combinatorOnly;
          }
          lastType = "other";
        }
      }
      if (regexStr === "") {
        return null;
      }
      return new RegExp(regexStr + "$");
    }
    function matchFurigana(body, toptext, options) {
      if (/^[=＝]/.test(toptext)) {
        return [body, toptext.slice(1)];
      }
      const bodyRegex = bodyToRegex(body);
      if (bodyRegex === null) {
        return [body, toptext];
      }
      const match = bodyRegex.exec(cleanFurigana(toptext, options));
      if (match === null) {
        return [body, toptext];
      }
      let result = [];
      let curBodyPart = "";
      let curToptextPart = "";
      let matchIndex = 1;
      let lastType = "other";
      for (let i = 0; i < body.length; i++) {
        const c = body.charAt(i);
        if (kanjiRegex.test(c)) {
          if (lastType === "kana" || lastType === "other") {
            if (curBodyPart !== "") {
              result.push(curBodyPart, curToptextPart);
            }
            curBodyPart = c;
            curToptextPart = match[matchIndex++];
            lastType = "kanji";
            continue;
          }
          const connection = match[matchIndex++];
          if (connection === "+" || connection === "") {
            curBodyPart += c;
            curToptextPart += match[matchIndex++];
          } else {
            result.push(curBodyPart, curToptextPart);
            curBodyPart = c;
            curToptextPart = match[matchIndex++];
          }
        } else {
          if (lastType !== "kanji") {
            curBodyPart += c;
            continue;
          }
          result.push(curBodyPart, curToptextPart);
          curBodyPart = c;
          curToptextPart = "";
          if (kanaRegex.test(c)) {
            lastType = "kana";
          } else {
            lastType = "other";
          }
        }
      }
      result.push(curBodyPart, curToptextPart);
      return result;
    }
    function cleanFurigana(furigana2, options) {
      furigana2 = furigana2.replace(options.separatorRegex, ".");
      furigana2 = furigana2.replace(options.combinatorRegex, "+");
      return furigana2;
    }
    function rubifyEveryCharacter(body, toptext) {
      let topmark = toptext.slice(1);
      if (topmark === "") {
        topmark = "●";
      }
      let result = [];
      for (let c of body) {
        result.push(c, topmark);
      }
      return result;
    }
    function furigana(options = {}) {
      options.fallbackParens = options.fallbackParens || "【】";
      options.extraSeparators = (options.extraSeparators || "").replace(
        /([\-\]\\])/g,
        "\\$1"
      );
      options.extraCombinators = (options.extraCombinators || "").replace(
        /([\-\]\\])/g,
        "\\$1"
      );
      options.separatorRegex = new RegExp(
        `[\\s.．。・|｜/／${options.extraSeparators}]`,
        "g"
      );
      options.combinatorRegex = new RegExp(`[+＋${options.extraCombinators}]`, "g");
      return function(state, silent) {
        return process(state, silent, options);
      };
    }
    function process(state, silent, options) {
      const ruby = rubyHelper.parse(state);
      if (ruby === null) {
        return false;
      }
      state.pos = ruby.nextPos;
      if (silent) {
        return true;
      }
      const emphasisDotsIndicatorRegex = /^[*＊].?/;
      if (emphasisDotsIndicatorRegex.test(ruby.toptext)) {
        const content = rubifyEveryCharacter(ruby.body, ruby.toptext);
        rubyHelper.addTag(state, content);
      } else {
        const content = matchFurigana(ruby.body, ruby.toptext, options);
        rubyHelper.addTag(state, content, options.fallbackParens);
      }
      return true;
    }
  }
});

// node_modules/.pnpm/furigana-markdown-it@1.0.3/node_modules/furigana-markdown-it/index.js
var require_furigana_markdown_it = __commonJS({
  "node_modules/.pnpm/furigana-markdown-it@1.0.3/node_modules/furigana-markdown-it/index.js"(exports, module) {
    module.exports = function(options) {
      return function(md) {
        md.inline.ruler.push("furigana", require_furigana()(options));
      };
    };
  }
});
export default require_furigana_markdown_it();
//# sourceMappingURL=furigana-markdown-it.js.map
