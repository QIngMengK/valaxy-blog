{
  "version": 3,
  "sources": ["../../.pnpm/furigana-markdown-it@1.0.3/node_modules/furigana-markdown-it/lib/ruby.js", "../../.pnpm/furigana-markdown-it@1.0.3/node_modules/furigana-markdown-it/lib/furigana.js", "../../.pnpm/furigana-markdown-it@1.0.3/node_modules/furigana-markdown-it/index.js"],
  "sourcesContent": ["\"use strict\";\n\nmodule.exports.parse = parse;\nmodule.exports.addTag = addTag;\n\n/**\n * Parses the [body]{toptext} syntax and returns\n * the body and toptext parts. These are then processed\n * in furigana.js and turned into \\<ruby\\> tags by\n * the {@link addTag} function.\n *\n * @param {*} state Markdown-it's inline state.\n * @returns {{body: string, toptext: string, nextPos: int}}\n * body: the main text part of the \\<ruby\\> tag.\n *\n * toptext: the top part of the \\<ruby\\> tag.\n *\n * nextPos: index of the next character in the markdown source.\n */\nfunction parse(state) {\n  if (state.src.charAt(state.pos) !== \"[\") {\n    return null;\n  }\n\n  const bodyStartBracket = state.pos;\n  const bodyEndBracket = state.src.indexOf(\"]\", bodyStartBracket);\n\n  if (\n    bodyEndBracket === -1 ||\n    bodyEndBracket >= state.posMax ||\n    state.src.charAt(bodyEndBracket + 1) !== \"{\"\n  ) {\n    return null;\n  }\n\n  const toptextStartBracket = bodyEndBracket + 1;\n  const toptextEndBracket = state.src.indexOf(\"}\", toptextStartBracket);\n\n  if (toptextEndBracket === -1 || toptextEndBracket >= state.posMax) {\n    return null;\n  }\n\n  const body = state.src.slice(bodyStartBracket + 1, bodyEndBracket);\n  const toptext = state.src.slice(toptextStartBracket + 1, toptextEndBracket);\n  if (body.trim() === \"\" || toptext.trim() === \"\") {\n    return null;\n  }\n\n  return {\n    body: body,\n    toptext: toptext,\n    nextPos: toptextEndBracket + 1\n  };\n}\n\n/**\n * Takes as content a flat array of main parts of\n * the ruby, each followed immediately by the text\n * that should show up above these parts.\n *\n * That content is then stored in its appropriate\n * representation in a markdown-it's inline state,\n * eventually resulting in a \\<ruby\\> tag.\n *\n * This function also gives you the option to add\n * fallback parentheses, should the \\<ruby\\>\n * tag be unsupported. In that case, the top text\n * of the ruby will instead be shown after the main\n * text, surrounded by these parentheses.\n *\n * @example\n * addTag(state, ['猫', 'ねこ', 'と', '', '犬', 'いぬ'])\n * // markdown-it will eventually produce a <ruby> tag\n * // with 猫と犬 as its main text, with ねこ corresponding\n * // to the 猫 kanji, and いぬ corresponding to the 犬 kanji.\n *\n * @param {*} state Markdown-it's inline state.\n * @param {string[]} content Flat array of main parts of\n *     the ruby, each followed by the text that should\n *     be above those parts.\n * @param {string} fallbackParens Parentheses to use\n *     as a fallback if the \\<ruby\\> tag happens to be\n *     unsupported. Example value: \"【】\".\n *     \"\" disables fallback parentheses.\n */\nfunction addTag(state, content, fallbackParens = \"\") {\n  function pushText(text) {\n    const token = state.push(\"text\", \"\", 0);\n    token.content = text;\n  }\n\n  state.push(\"ruby_open\", \"ruby\", 1);\n\n  for (let i = 0; i < content.length; i += 2) {\n    const body = content[i];\n    const toptext = content[i + 1];\n\n    pushText(body);\n\n    if (toptext === \"\") {\n      state.push(\"rt_open\", \"rt\", 1);\n      state.push(\"rt_close\", \"rt\", -1);\n      continue;\n    }\n\n    if (fallbackParens !== \"\") {\n      state.push(\"rp_open\", \"rp\", 1);\n      pushText(fallbackParens.charAt(0));\n      state.push(\"rp_close\", \"rp\", -1);\n    }\n\n    state.push(\"rt_open\", \"rt\", 1);\n    pushText(toptext);\n    state.push(\"rt_close\", \"rt\", -1);\n\n    if (fallbackParens !== \"\") {\n      state.push(\"rp_open\", \"rp\", 1);\n      pushText(fallbackParens.charAt(1));\n      state.push(\"rp_close\", \"rp\", -1);\n    }\n  }\n\n  state.push(\"ruby_close\", \"ruby\", -1);\n}\n", "\"use strict\";\n\nmodule.exports = furigana;\n\nconst rubyHelper = require(\"./ruby\");\n\nconst kanaRegex = /[\\u3040-\\u3096\\u30a1-\\u30fa\\uff66-\\uff9fー]/;\nconst kanjiRegex = /[\\u3400-\\u9faf]/;\n\n/**\n * Furigana is marked using the [body]{furigana} syntax.\n * First step, performed by bodyToRegex, is to convert\n * the body to a regex, which can then be used to pattern\n * match on the furigana.\n *\n * In essence, every kanji needs to be converted to a\n * pattern similar to \".?\", so that it can match some kana\n * from the furigana part. However, this alone is ambiguous.\n * Consider [可愛い犬]{かわいいいぬ}: in this case there are\n * three different ways to assign furigana in the body.\n *\n * Ambiguities can be resolved by adding separator characters\n * in the furigana. These are only matched at the\n * boundaries between kanji and other kanji/kana.\n * So a regex created from 可愛い犬 should be able to match\n * か・わい・い・いぬ, but a regex created from 美味しい shouldn't\n * be able to match おいし・い.\n *\n * For purposes of this function, only ASCII dot is a\n * separators. Other characters are converted to dots in\n * the {@link cleanFurigana} function.\n *\n * The notation [可愛い犬]{か・わい・い・いぬ} forces us to\n * have separate \\<rt\\> tags for 可 and 愛. If we want to\n * indicate that か corresponds to 可 and わい corresponds to 愛\n * while keeping them under a single \\<rt\\> tag, we can use\n * a combinator instead of a separator, e.g.:\n * [可愛い犬]{か+わい・い・いぬ}\n *\n * For purposes of this function, only ASCII plus is a\n * combinator. Other characters are converted to pluses in\n * the {@link cleanFurigana} function.\n *\n * @param {string} body The non-furigana part.\n * @returns {(null|RegExp)} Null if the body contains no hiragana\n *     or kanji, otherwise a regex to be used on the furigana.\n */\nfunction bodyToRegex(body) {\n  let regexStr = \"^\";\n  let lastType = \"other\";\n\n  const combinatorOrSeparatorGroup = \"([+.]?)\";\n  const combinatorOrSeparator = \"[+.]?\";\n  const combinatorOnly = \"\\\\.?\";\n  const furiganaGroup = \"([^+.]+)\";\n\n  for (let i = 0; i < body.length; i++) {\n    const c = body.charAt(i);\n    if (kanjiRegex.test(c)) {\n      if (lastType === \"kanji\") {\n        regexStr += combinatorOrSeparatorGroup;\n      } else if (lastType === \"kana\") {\n        regexStr += combinatorOrSeparator;\n      }\n\n      regexStr += furiganaGroup;\n      lastType = \"kanji\";\n    } else if (kanaRegex.test(c)) {\n      if (lastType == \"kanji\") {\n        regexStr += combinatorOrSeparator;\n      }\n      regexStr += c;\n      lastType = \"kana\";\n    } else {\n      if (lastType !== \"other\") {\n        regexStr += combinatorOnly;\n      }\n      lastType = \"other\";\n    }\n  }\n\n  if (regexStr === \"\") {\n    return null;\n  }\n  return new RegExp(regexStr + \"$\");\n}\n\n/**\n * For a ruby tag specified as [body]{toptext}, tries to find\n * the appropriate furigana in the toptext for every kanji\n * in the body.\n *\n * The result is a flat array where each part of the body\n * is followed by its corresponding furigana. Or, if no\n * such correspondence can be found, just [body, toptext]\n * is returned.\n *\n * As a special case, if toptext starts with = or ＝, the\n * pattern-matching functionality is disabled, and only\n * [body, toptext-without-the-equals-sign] is returned.\n *\n * @example\n * r = matchFurigana('美味しいご飯', 'おいしいごはん')\n * assert(r == ['美味', 'おい', 'しいご', '', '飯', 'はん'])\n *\n * @example\n * // no match\n * r = matchFurigana('食べる', 'たべべ')\n * assert(r == ['食べる', 'たべべ'])\n *\n * @example\n * // disabled pattern matching\n * r = matchFurigana('食べる', '＝たべる')\n * assert(r == ['食べる', 'たべる'])\n *\n * @param {string} body\n * @param {string} toptext\n * @returns {string[]} Flat array of parts of the body followed\n *     by their corresponding furigana, or just [body, toptext]\n *     if no such correspondence exists.\n */\nfunction matchFurigana(body, toptext, options) {\n  if (/^[=＝]/.test(toptext)) {\n    return [body, toptext.slice(1)];\n  }\n\n  const bodyRegex = bodyToRegex(body);\n  if (bodyRegex === null) {\n    return [body, toptext];\n  }\n\n  const match = bodyRegex.exec(cleanFurigana(toptext, options));\n  if (match === null) {\n    return [body, toptext];\n  }\n\n  let result = [];\n  let curBodyPart = \"\";\n  let curToptextPart = \"\";\n  let matchIndex = 1;\n  let lastType = \"other\";\n  for (let i = 0; i < body.length; i++) {\n    const c = body.charAt(i);\n\n    if (kanjiRegex.test(c)) {\n      if (lastType === \"kana\" || lastType === \"other\") {\n        if (curBodyPart !== \"\") {\n          result.push(curBodyPart, curToptextPart);\n        }\n        curBodyPart = c;\n        curToptextPart = match[matchIndex++];\n        lastType = \"kanji\";\n        continue;\n      }\n\n      const connection = match[matchIndex++];\n      if (connection === \"+\" || connection === \"\") {\n        curBodyPart += c;\n        curToptextPart += match[matchIndex++];\n      } else {\n        result.push(curBodyPart, curToptextPart);\n        curBodyPart = c;\n        curToptextPart = match[matchIndex++];\n      }\n    } else {\n      if (lastType !== \"kanji\") {\n        curBodyPart += c;\n        continue;\n      }\n\n      result.push(curBodyPart, curToptextPart);\n      curBodyPart = c;\n      curToptextPart = \"\";\n\n      if (kanaRegex.test(c)) {\n        lastType = \"kana\";\n      } else {\n        lastType = \"other\";\n      }\n    }\n  }\n\n  result.push(curBodyPart, curToptextPart);\n  return result;\n}\n\n/**\n * \"Cleans\" the furigana by converting all allowed\n * separators to ASCII dots and all allowed combinators\n * to ASCII pluses.\n *\n * The meaning of \"separator\" and \"combinator\" is\n * described in the {@link bodyToRegex} function.\n *\n * @param {string} furigana\n * @returns {string} Clean version of the furigana.\n */\nfunction cleanFurigana(furigana, options) {\n  furigana = furigana.replace(options.separatorRegex, \".\");\n  furigana = furigana.replace(options.combinatorRegex, \"+\");\n  return furigana;\n}\n\n/**\n * Parallel to the {@link matchFurigana} function,\n * but instead of doing any matching it just adds\n * toptext to every character of the body. This\n * is intended to be used for emphasis dots, like\n * you sometimes see in manga.\n *\n * For this, toptext is expected to start with\n * an asterisk (ASCII or full-width), and the actual\n * marker that should be placed after every character\n * should follow afterward.\n *\n * If no marker is provided, a circle (●) is used.\n *\n * Since this is meant to mimic the return value of the\n * {@link matchFurigana} function, the result is just an array\n * of characters from the body followed by the marker.\n *\n * @example\n * r = rubifyEveryCharacter('だから', '*')\n * assert(r == ['だ', '●', 'か', '●', 'ら', '●'])\n *\n * @example\n * r = rubifyEveryCharacter('だから', '*+')\n * assert(r == ['だ', '+', 'か', '+', 'ら', '+'])\n *\n * @param {string} body\n * @param {string} toptext\n * @returns {string[]} Flat array of characters of the body,\n *     each one followed by the marker as specified in toptext.\n */\nfunction rubifyEveryCharacter(body, toptext) {\n  let topmark = toptext.slice(1);\n  if (topmark === \"\") {\n    topmark = \"●\";\n  }\n\n  let result = [];\n  for (let c of body) {\n    result.push(c, topmark);\n  }\n  return result;\n}\n\n/**\n * Returns a function that's compatible for use with\n * markdown-it's inline ruler. The function is further\n * customizable via the options.\n *\n * Available options:\n * - fallbackParens: fallback parentheses for the resulting\n *     \\<ruby\\> tags. Default value: \"【】\".\n * - extraSeparators: additional characters that can be used\n *     to separate furigana. Empty by default. Example value:\n *     \"_-*\".\n *\n *     The characters that are already hard-coded as\n *     separator characters are any kind of space, as well as\n *     these: \".．。・|｜/／\".\n * - extraCombinators: additional characters that can be used\n *     to indicate a kanji boundary without actually splitting\n *     the furigana. Empty by default.\n *\n *     The characters that are already hard-coded as\n *     combinator characters are '+' and '＋'.\n *\n * @param {Object} options\n */\nfunction furigana(options = {}) {\n  options.fallbackParens = options.fallbackParens || \"【】\";\n\n  options.extraSeparators = (options.extraSeparators || \"\").replace(\n    /([\\-\\]\\\\])/g,\n    \"\\\\$1\"\n  );\n  options.extraCombinators = (options.extraCombinators || \"\").replace(\n    /([\\-\\]\\\\])/g,\n    \"\\\\$1\"\n  );\n\n  options.separatorRegex = new RegExp(\n    `[\\\\s.．。・|｜/／${options.extraSeparators}]`,\n    \"g\"\n  );\n  options.combinatorRegex = new RegExp(`[+＋${options.extraCombinators}]`, \"g\");\n\n  return function(state, silent) {\n    return process(state, silent, options);\n  };\n}\n\n/**\n * Processes furigana by converting [kanji]{furigana}\n * into required markdown-it tokens. This is meant to be\n * hooked up to markdown-it's inline ruleset.\n *\n * Refer to {@link furigana} for available options.\n *\n * @param {*} state Markdown-it's inline state.\n * @param {boolean} silent If true, no tokens are actually generated.\n * @param {Object} options\n * @returns {boolean} Whether the function successfully processed the text.\n */\nfunction process(state, silent, options) {\n  const ruby = rubyHelper.parse(state);\n  if (ruby === null) {\n    return false;\n  }\n\n  state.pos = ruby.nextPos;\n\n  if (silent) {\n    return true;\n  }\n\n  const emphasisDotsIndicatorRegex = /^[*＊].?/;\n  if (emphasisDotsIndicatorRegex.test(ruby.toptext)) {\n    const content = rubifyEveryCharacter(ruby.body, ruby.toptext);\n    rubyHelper.addTag(state, content);\n  } else {\n    const content = matchFurigana(ruby.body, ruby.toptext, options);\n    rubyHelper.addTag(state, content, options.fallbackParens);\n  }\n\n  return true;\n}\n", "\"use strict\";\n\nmodule.exports = function(options) {\n  return function(md) {\n    md.inline.ruler.push(\"furigana\", require(\"./lib/furigana\")(options));\n  };\n};\n"],
  "mappings": "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",
  "names": ["furigana"]
}
