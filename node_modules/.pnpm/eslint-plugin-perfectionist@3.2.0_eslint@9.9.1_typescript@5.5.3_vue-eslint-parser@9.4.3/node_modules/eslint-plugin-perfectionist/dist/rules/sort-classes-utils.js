'use strict'
Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' })
const cachedGroupsByModifiersAndSelectors = /* @__PURE__ */ new Map()
const generateOfficialGroups = (modifiers, selectors) => {
  let modifiersAndSelectorsKey = modifiers.join('&') + '/' + selectors.join('&')
  let cachedValue = cachedGroupsByModifiersAndSelectors.get(
    modifiersAndSelectorsKey,
  )
  if (cachedValue) {
    return cachedValue
  }
  let allModifiersCombinations = []
  for (let i = modifiers.length; i > 0; i--) {
    allModifiersCombinations = [
      ...allModifiersCombinations,
      ...getCombinations(modifiers, i),
    ]
  }
  let allModifiersCombinationPermutations = allModifiersCombinations.flatMap(
    result => getPermutations(result),
  )
  let returnValue = []
  for (let selector of selectors) {
    returnValue = [
      ...returnValue,
      ...allModifiersCombinationPermutations.map(
        modifiersCombinationPermutation =>
          [...modifiersCombinationPermutation, selector].join('-'),
      ),
      selector,
    ]
  }
  cachedGroupsByModifiersAndSelectors.set(modifiersAndSelectorsKey, returnValue)
  return returnValue
}
const getCombinations = (array, n) => {
  let result = []
  let backtrack = (start, comb) => {
    if (comb.length === n) {
      result.push([...comb])
      return
    }
    for (let i = start; i < array.length; i++) {
      comb.push(array[i])
      backtrack(i + 1, comb)
      comb.pop()
    }
  }
  backtrack(0, [])
  return result
}
const getPermutations = elements => {
  let result = []
  let backtrack = first => {
    if (first === elements.length) {
      result.push([...elements])
      return
    }
    for (let i = first; i < elements.length; i++) {
      ;[elements[first], elements[i]] = [elements[i], elements[first]]
      backtrack(first + 1)
      ;[elements[first], elements[i]] = [elements[i], elements[first]]
    }
  }
  backtrack(0)
  return result
}
exports.generateOfficialGroups = generateOfficialGroups
