"use strict";
var overlayCore = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    UnifiedOverlayProviderID: () => UnifiedOverlayProviderID,
    allowed: () => allowed,
    createConstructor: () => createConstructor,
    createDeferred: () => createDeferred,
    defineGlobalElement: () => defineGlobalElement,
    defineName: () => defineName,
    delay: () => delay,
    getIndex: () => getIndex,
    noop: () => noop
  });

  // src/define/global.ts
  var UnifiedOverlayProviderID = "unified-overlay";
  function defineGlobalElement(id = "", root = document.body) {
    const el = document.createElement("div");
    if (id)
      el.id = id;
    if (root !== false)
      root.appendChild(el);
    return el;
  }

  // src/internal/index.ts
  var context = {
    position: null,
    spaces: {}
  };

  // src/define/name-index.ts
  function defineName(id = UnifiedOverlayProviderID, auto = true) {
    if (!context.spaces[id])
      context.spaces[id] = 0;
    if (auto)
      return `${id}--${++context.spaces[id]}`;
    return id;
  }
  function getIndex(id = UnifiedOverlayProviderID) {
    return context.spaces[id] || 0;
  }

  // src/deferred.ts
  function createDeferred() {
    let resolve, reject;
    const promise = new Promise((_resolve, _reject) => {
      resolve = _resolve;
      reject = _reject;
    });
    promise.resolve = (v) => {
      resolve(v);
      return promise;
    };
    promise.reject = reject;
    return promise;
  }

  // src/events/index.ts
  function watchClickPosition() {
    if (typeof window === "undefined" && typeof document === "undefined")
      return;
    document.addEventListener("click", (event) => {
      if (event.target instanceof Element) {
        const { left, top, width, height } = event.target.getBoundingClientRect();
        if (left > 0 || top > 0) {
          context.position = { x: left + width / 2, y: top + height / 2 };
        } else {
          context.position = null;
        }
      } else {
        context.position = null;
      }
      setTimeout(() => context.position = null, 64);
    });
  }

  // src/constructor.ts
  function createConstructor(mount) {
    function define(instance, options) {
      function executor(props, options2) {
        const deferred = createDeferred();
        const name = defineName(options2.id, options2.autoIncrement);
        const index = getIndex(options2.id);
        const container = defineGlobalElement(name, options2.root);
        mount(instance, props, Object.assign(options2, {
          position: context.position,
          id: name,
          deferred,
          index,
          container
        }));
        return deferred;
      }
      let inst;
      function only(props, options2) {
        if (!inst) {
          inst = executor(props, options2);
          inst.finally(() => inst = void 0);
        }
        return inst;
      }
      function caller(props, overrides) {
        const opts = { ...options, ...overrides };
        return opts.only ? only(props, opts) : executor(props, opts);
      }
      return caller;
    }
    function render(instance, props, options) {
      return define(instance, options)(props);
    }
    return { define, render };
  }
  watchClickPosition();

  // src/utils/util.ts
  function noop() {
  }
  function allowed() {
    throw new Error("overlay - Error: It is not allowed to call resolve and reject externally immediately, please wait for the component to render");
  }
  function delay(milliseconds) {
    return new Promise((resolve) => setTimeout(resolve, milliseconds));
  }
  return __toCommonJS(src_exports);
})();
