// src/define/global.ts
var UnifiedOverlayProviderID = "unified-overlay";
function defineGlobalElement(id = "", root = document.body) {
  const el = document.createElement("div");
  if (id)
    el.id = id;
  if (root !== false)
    root.appendChild(el);
  return el;
}

// src/internal/index.ts
var context = {
  position: null,
  spaces: {}
};

// src/define/name-index.ts
function defineName(id = UnifiedOverlayProviderID, auto = true) {
  if (!context.spaces[id])
    context.spaces[id] = 0;
  if (auto)
    return `${id}--${++context.spaces[id]}`;
  return id;
}
function getIndex(id = UnifiedOverlayProviderID) {
  return context.spaces[id] || 0;
}

// src/deferred.ts
function createDeferred() {
  let resolve, reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  promise.resolve = (v) => {
    resolve(v);
    return promise;
  };
  promise.reject = reject;
  return promise;
}

// src/events/index.ts
function watchClickPosition() {
  if (typeof window === "undefined" && typeof document === "undefined")
    return;
  document.addEventListener("click", (event) => {
    if (event.target instanceof Element) {
      const { left, top, width, height } = event.target.getBoundingClientRect();
      if (left > 0 || top > 0) {
        context.position = { x: left + width / 2, y: top + height / 2 };
      } else {
        context.position = null;
      }
    } else {
      context.position = null;
    }
    setTimeout(() => context.position = null, 64);
  });
}

// src/constructor.ts
function createConstructor(mount) {
  function define(instance, options) {
    function executor(props, options2) {
      const deferred = createDeferred();
      const name = defineName(options2.id, options2.autoIncrement);
      const index = getIndex(options2.id);
      const container = defineGlobalElement(name, options2.root);
      mount(instance, props, Object.assign(options2, {
        position: context.position,
        id: name,
        deferred,
        index,
        container
      }));
      return deferred;
    }
    let inst;
    function only(props, options2) {
      if (!inst) {
        inst = executor(props, options2);
        inst.finally(() => inst = void 0);
      }
      return inst;
    }
    function caller(props, overrides) {
      const opts = { ...options, ...overrides };
      return opts.only ? only(props, opts) : executor(props, opts);
    }
    return caller;
  }
  function render(instance, props, options) {
    return define(instance, options)(props);
  }
  return { define, render };
}
watchClickPosition();

// src/utils/util.ts
function noop() {
}
function allowed() {
  throw new Error("overlay - Error: It is not allowed to call resolve and reject externally immediately, please wait for the component to render");
}
function delay(milliseconds) {
  return new Promise((resolve) => setTimeout(resolve, milliseconds));
}
export {
  UnifiedOverlayProviderID,
  allowed,
  createConstructor,
  createDeferred,
  defineGlobalElement,
  defineName,
  delay,
  getIndex,
  noop
};
